{"items":[{"owner":{"reputation":13581,"user_id":9957710,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-xgjNutv-CqM/AAAAAAAAAAI/AAAAAAAABS8/EBDwfir_mYk/photo.jpg?sz=128","display_name":"Przemyslaw Szufel","link":"https://stackoverflow.com/users/9957710/przemyslaw-szufel"},"is_accepted":false,"score":1,"last_activity_date":1605567324,"last_edit_date":1605567324,"creation_date":1605566851,"answer_id":64866831,"question_id":64863201,"content_license":"CC BY-SA 4.0","body":"<p>Assuming that your definition is the following:</p>\n<blockquote>\n<p>a diagonally dominant matrix is a square matrix such that in each row, the absolute value of the term on the diagonal is greater than or equal to the sum of absolute values of the rest of the terms in that row</p>\n</blockquote>\n<p>You can use this code to check whether matrix <code>a</code> is diagonally dominant (requires <code>using LinearAlgebra</code>):</p>\n<pre><code>all(sum(abs.(a),dims=2) .&lt;= 2abs.(diag(a)))\n</code></pre>\n"},{"owner":{"reputation":61,"user_id":14648485,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/bfa652b8e82666305d2b5e51efa55bef?s=128&d=identicon&r=PG&f=1","display_name":"YuliyaCl","link":"https://stackoverflow.com/users/14648485/yuliyacl"},"is_accepted":false,"score":2,"last_activity_date":1605540926,"creation_date":1605540926,"answer_id":64860930,"question_id":64859819,"content_license":"CC BY-SA 4.0","body":"<p>I've re-run Atom again in administrator mode and all errors disappeared. Now everything works without admin mode also. Magic.</p>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":false,"score":2,"last_activity_date":1605537306,"creation_date":1605537306,"answer_id":64859944,"question_id":64858824,"content_license":"CC BY-SA 4.0","body":"<p>Here is an alternative solution using double <code>groupby</code>-<code>combine</code> strategy that is slightly faster:</p>\n<pre><code>julia&gt; df = repeat(DataFrame(a = rand([&quot;a&quot;, &quot;b&quot;], 20), b = rand(1:5, 20)), 10^6);\n\njulia&gt; @btime combine(groupby($df, :a), :b =&gt; length ∘ unique =&gt; :n_distinct_b);\n  650.915 ms (237 allocations: 866.37 MiB)\n\njulia&gt; @btime combine(groupby(combine(groupby($df, [:a, :b]), nrow), :a), nrow =&gt; :n_distinct_b);\n  457.884 ms (346 allocations: 561.20 MiB)\n</code></pre>\n<p>(but what Nils proposed is more natural)</p>\n"},{"owner":{"reputation":5870,"user_id":2499892,"user_type":"registered","accept_rate":76,"profile_image":"https://i.stack.imgur.com/VeDpx.jpg?s=128&g=1","display_name":"Nils Gudat","link":"https://stackoverflow.com/users/2499892/nils-gudat"},"is_accepted":true,"score":3,"last_activity_date":1605534998,"creation_date":1605534998,"answer_id":64859390,"question_id":64858824,"content_license":"CC BY-SA 4.0","body":"<p>I think you should be able to do</p>\n<pre><code>combine(groupby(df, :A), :B =&gt; length ∘ unique =&gt; :n_distint_B)\n</code></pre>\n<p>like this:</p>\n<pre><code>julia&gt; using DataFrames\n\njulia&gt; df = DataFrame(a = rand([&quot;a&quot;, &quot;b&quot;], 20), b = rand(1:5, 20))\n20×2 DataFrame\n Row │ a       b     \n     │ String  Int64 \n─────┼───────────────\n   1 │ a           3\n   2 │ b           4\n   3 │ a           1\n   4 │ a           1\n   5 │ b           1\n   6 │ a           2\n   7 │ b           4\n   8 │ a           2\n   9 │ b           2\n  10 │ b           1\n  11 │ b           3\n  12 │ b           3\n  13 │ a           4\n  14 │ a           4\n  15 │ b           3\n  16 │ b           2\n  17 │ a           5\n  18 │ a           5\n  19 │ b           5\n  20 │ a           1\n\njulia&gt; combine(groupby(df, :a), :b =&gt; length ∘ unique =&gt; :n_distinct_b)\n2×2 DataFrame\n Row │ a       n_distinct_b \n     │ String  Int64        \n─────┼──────────────────────\n   1 │ a                  5\n   2 │ b                  5\n</code></pre>\n"},{"owner":{"reputation":663,"user_id":3401312,"user_type":"registered","profile_image":"https://i.stack.imgur.com/fSLLB.jpg?s=128&g=1","display_name":"Jun Tian","link":"https://stackoverflow.com/users/3401312/jun-tian"},"is_accepted":false,"score":3,"last_activity_date":1605532994,"creation_date":1605532994,"answer_id":64858825,"question_id":64857778,"content_license":"CC BY-SA 4.0","body":"<p>I used to have also been struggled to remember the variable order. Until one day someone told me a <em>secret</em>: just treat the order of <code>for</code> loop in the list comprehension as usual except that the body is moved to the front.</p>\n<p>For example, in <em>normal</em> order we write:</p>\n<pre><code>for x in 1:3\n    for y in 1:x\n        # do sth\n    end\nend\n</code></pre>\n<p>Now we move the body part to the front and we have <code>[ #= do sth =# for x in 1:3 for y in 1:x]</code></p>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":true,"score":3,"last_activity_date":1605531825,"creation_date":1605531825,"answer_id":64858532,"question_id":64857778,"content_license":"CC BY-SA 4.0","body":"<p>Just reverse the order of variables like this:</p>\n<pre><code>julia&gt; [(x,y) for x in 1:3 for y in 1:x]\n6-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (2, 1)\n (2, 2)\n (3, 1)\n (3, 2)\n (3, 3)\n</code></pre>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":false,"score":1,"last_activity_date":1605522258,"creation_date":1605522258,"answer_id":64856259,"question_id":64855265,"content_license":"CC BY-SA 4.0","body":"<p>AFAICT functions in Julia are considered to be bits type:</p>\n<pre><code>julia&gt; f(x) = x\nf (generic function with 1 method)\n\njulia&gt; isbitstype(typeof(f))\ntrue\n</code></pre>\n<p>which means that <code>deepcopy</code> on them is a no-op. Here is a definition of <code>deepcopy</code>:</p>\n<pre><code>function deepcopy(x)\n    isbitstype(typeof(x)) &amp;&amp; return x\n    return deepcopy_internal(x, IdDict())::typeof(x)\nend\n</code></pre>\n<p>The reason for this is that each function has its own type (but it can have many methods).</p>\n<p>The solution that phipsgabler proposes works because each time you define an anonymous function it gets its own new type. See here:</p>\n<pre><code>julia&gt; typeof(x -&gt; x)\nvar&quot;#1#2&quot;\n\njulia&gt; typeof(x -&gt; x)\nvar&quot;#3#4&quot;\n\njulia&gt; typeof(x -&gt; x)\nvar&quot;#5#6&quot;\n</code></pre>\n<p>This has one downside though - each time you pass an fresh anonymous function to another function it has to be compiled, e.g.:</p>\n<pre><code>julia&gt; @time map(x -&gt; x, 1:2);\n  0.024220 seconds (49.61 k allocations: 2.734 MiB)\n\njulia&gt; @time map(x -&gt; x, 1:2);\n  0.023754 seconds (48.25 k allocations: 2.530 MiB)\n\njulia&gt; @time map(x -&gt; x, 1:2);\n  0.023336 seconds (48.25 k allocations: 2.530 MiB)\n</code></pre>\n<p>vs</p>\n<pre><code>julia&gt; fun = x -&gt; x\n#7 (generic function with 1 method)\n\njulia&gt; @time map(fun, 1:2);\n  0.023459 seconds (48.23 k allocations: 2.530 MiB)\n\njulia&gt; @time map(fun, 1:2);\n  0.000016 seconds (4 allocations: 192 bytes)\n\njulia&gt; @time map(fun, 1:2);\n  0.000013 seconds (4 allocations: 192 bytes)\n</code></pre>\n<p>Going back to your original question. Even if you write something like:</p>\n<pre><code>julia&gt; f(x) = x\nf (generic function with 1 method)\n\njulia&gt; g = x -&gt; f(x)\n#1 (generic function with 1 method)\n\njulia&gt; g(1)\n1\n</code></pre>\n<p>you get:</p>\n<pre><code>julia&gt; f(x) = 2x\nf (generic function with 1 method)\n\njulia&gt; g(1)\n2\n</code></pre>\n<p>because <code>f(x) = 2x</code> replaces the method for the function <code>f</code> but its type does not change (as commented above - one function can have many methods and you can even update the methods of the function as in the example above). This is related to a so called &quot;world age&quot; issue that you have explained <a href=\"https://docs.julialang.org/en/v1/manual/methods/#Redefining-Methods\" rel=\"nofollow noreferrer\">here</a> in the Julia manual.</p>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":false,"score":1,"last_activity_date":1605503243,"creation_date":1605503243,"answer_id":64852944,"question_id":64849353,"content_license":"CC BY-SA 4.0","body":"<p>You can use <a href=\"https://github.com/JuliaIO/Suppressor.jl\" rel=\"nofollow noreferrer\">Suppressor.jl</a> to suppress all warnings.</p>\n<p>Your code would like like this:</p>\n<pre><code>using Suppressor\n@suppress begin\n    v1 = @vlplot(:circle,x=α[:,1],y=α[:,2])\n    v2 = @vlplot(mark={&quot;type&quot;=:circle,color=&quot;red&quot;},x=β[:,1],y=β[:,2])\n    @vlplot()+v1+v2\nend\n</code></pre>\n<p>See other usage examples here: <a href=\"https://github.com/JuliaIO/Suppressor.jl#usage\" rel=\"nofollow noreferrer\">https://github.com/JuliaIO/Suppressor.jl#usage</a></p>\n"},{"owner":{"reputation":493,"user_id":13591160,"user_type":"registered","profile_image":"https://lh6.googleusercontent.com/-gXrgnmUK7Sg/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rfsMAFVGT8ih3UFFA8KqqALLKEGwA/photo.jpg?sz=128","display_name":"Oscar Dowson","link":"https://stackoverflow.com/users/13591160/oscar-dowson"},"is_accepted":true,"score":2,"last_activity_date":1605481557,"creation_date":1605481557,"answer_id":64850720,"question_id":64828076,"content_license":"CC BY-SA 4.0","body":"<p>MathOptInterface has a cone for the spectral norm:</p>\n<p><a href=\"https://jump.dev/MathOptInterface.jl/v0.9/apireference/#MathOptInterface.NormSpectralCone\" rel=\"nofollow noreferrer\">https://jump.dev/MathOptInterface.jl/v0.9/apireference/#MathOptInterface.NormSpectralCone</a></p>\n<pre><code>@constraint(model, [maxnorm; vec(A)] in MOI.NormSpectralCone(4, 5))\n</code></pre>\n"},{"owner":{"reputation":493,"user_id":13591160,"user_type":"registered","profile_image":"https://lh6.googleusercontent.com/-gXrgnmUK7Sg/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rfsMAFVGT8ih3UFFA8KqqALLKEGwA/photo.jpg?sz=128","display_name":"Oscar Dowson","link":"https://stackoverflow.com/users/13591160/oscar-dowson"},"is_accepted":true,"score":1,"last_activity_date":1605481434,"creation_date":1605481434,"answer_id":64850702,"question_id":64844626,"content_license":"CC BY-SA 4.0","body":"<p>I'm not sure how Supressor works, but the way to resolve this with <code>Gurobi.jl</code> is to re-use an environment for multiple solves:</p>\n<p><a href=\"https://github.com/jump-dev/Gurobi.jl#reusing-the-same-gurobi-environment-for-multiple-solves\" rel=\"nofollow noreferrer\">https://github.com/jump-dev/Gurobi.jl#reusing-the-same-gurobi-environment-for-multiple-solves</a></p>\n"},{"owner":{"reputation":523,"user_id":11829634,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/861c79c7e9910801e46fee3070725b0f?s=128&d=identicon&r=PG&f=1","display_name":"Miguel","link":"https://stackoverflow.com/users/11829634/miguel"},"is_accepted":false,"score":4,"last_activity_date":1605480340,"creation_date":1605480340,"answer_id":64850579,"question_id":64846026,"content_license":"CC BY-SA 4.0","body":"<p>As far as I'm aware (and I would love to be proven wrong) there is no efficient way to get all the eigenvalues of a general sparse matrix.</p>\n<p>The main algorithm to compute the eigenvalues of a matrix is the QR algorithm. The first step of the QR algorithm is to reduce the matrix to a Hessenberg form (in order to do the QR factorisations in O(n) time). The problem is that reducing a matrix to Hessenberg form destroys the sparsity and you just end up with a dense matrix.</p>\n<p>There are also other methods to compute the eigenvalues of a matrix like the (inverse) power iteration, that only require matrix vector products and solving linear systems, but these only give you the largest or smallest eigenvalues, and they become expensive when you want to compute all the eigenvalues (they require storing the eigenvectors for the &quot;deflation&quot;).</p>\n<p>So that was in general, now if your matrix has some special structure there may some better alternatives. For example, if your matrix is symmetric, then its Hessenberg form is tridiagonal and you can compute all the eigenvalues pretty fast.</p>\n<p><strong>TLDR</strong>: Is it possible ? — in general, no.</p>\n<p>P.S: I tried to keep this short but if you're interested I can give you more details on any part of the answer.</p>\n"},{"owner":{"reputation":11,"user_id":14620937,"user_type":"registered","profile_image":"https://i.stack.imgur.com/RrxLE.jpg?s=128&g=1","display_name":"Tim Madden","link":"https://stackoverflow.com/users/14620937/tim-madden"},"is_accepted":true,"score":0,"last_activity_date":1605475170,"creation_date":1605475170,"answer_id":64849901,"question_id":64792254,"content_license":"CC BY-SA 4.0","body":"<p>I finally got it working.  In vs-code there is a bright blue bar at the bottom.  Clicking Julia env: and changing it from v1.5 to JulaiPro_v1.5.2-1 fixed everything.</p>\n<p>It has something to do with:</p>\n<pre><code>julia&gt; Base.load_path()\n3-element Array{String,1}:\n &quot;C:\\\\Users\\\\&lt;user&gt;\\\\.julia\\\\environments\\\\JuliaPro_v1.5.2-1\\\\Project.toml&quot;\n &quot;C:\\\\Users\\\\&lt;user&gt;\\\\.julia\\\\environments\\\\v1.5\\\\Project.toml&quot;\n &quot;C:\\\\Users\\\\&lt;user&gt;\\\\AppData\\\\Local\\\\JuliaPro-1.5.2-1\\\\Julia-1.5.2\\\\share\\\\julia\\\\stdlib\\\\v1.5&quot;\n</code></pre>\n<p>The v1.5 path didn't exist.</p>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":false,"score":3,"last_activity_date":1605454171,"creation_date":1605454171,"answer_id":64846260,"question_id":64846259,"content_license":"CC BY-SA 4.0","body":"<p>This is a common issue when you lose connection to the Julia Registry (which is where packages are pulled from). You can first type <code>]</code> to enter pkg mode in the Julia Repl and then do the following:</p>\n<pre><code>\n(@v1.5) pkg&gt; registry remove General\n   Removing registry `General` from ~/.julia/registries/General\n\n(@v1.5) pkg&gt; registry add https://github.com/JuliaRegistries/General.git\n    Cloning registry from &quot;https://github.com/JuliaRegistries/General.git&quot;\n      Added registry `General` to `~/.julia/registries/General`\n</code></pre>\n<p>Try to add the Package again and the issue should be resolved.</p>\n"},{"owner":{"reputation":13581,"user_id":9957710,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-xgjNutv-CqM/AAAAAAAAAAI/AAAAAAAABS8/EBDwfir_mYk/photo.jpg?sz=128","display_name":"Przemyslaw Szufel","link":"https://stackoverflow.com/users/9957710/przemyslaw-szufel"},"is_accepted":true,"score":2,"last_activity_date":1605454079,"creation_date":1605454079,"answer_id":64846241,"question_id":64845551,"content_license":"CC BY-SA 4.0","body":"<p>Have a look at read very carefully <a href=\"https://docs.julialang.org/en/v1/manual/performance-tips/\" rel=\"nofollow noreferrer\">https://docs.julialang.org/en/v1/manual/performance-tips/</a></p>\n<p>Basic cleanups start with:</p>\n<ol>\n<li>Your <code>SpotPrices</code> <code>struct</code> does not need to me mutable. Anyway since there is only one field you could just define it as <code>SpotPrices=Vector{Float64}</code></li>\n<li>You do not want untyped containers - instead of  <code>prices = []</code> do <code>prices = Float64[]</code></li>\n<li>Using <code>DataFrames.groupby</code> will be much faster than finding unique elements and filtering by them</li>\n<li>If yo do not need initialze than do not do it <code>Vector{Float64}(undef, sample_size)</code>  is much faster than <code>zeros(sample_size, 24)</code></li>\n<li>You do not need to synchronize <code>@sync</code> before a multi-threaded loop</li>\n<li>Create a random states - one separate one for each thread and use them whenever calling the <code>rand</code> function</li>\n</ol>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":false,"score":0,"last_activity_date":1605449644,"creation_date":1605449644,"answer_id":64845411,"question_id":64769876,"content_license":"CC BY-SA 4.0","body":"<p>As Jun pointed out in the comments, please open an issue here: <a href=\"https://github.com/JuliaIO/ProtoBuf.jl/issues\" rel=\"nofollow noreferrer\">https://github.com/JuliaIO/ProtoBuf.jl/issues</a> to document this and hopefully get a more elegant pure Julia solution for it.</p>\n"},{"owner":{"reputation":9651,"user_id":1939814,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/2989a078f4caff6fb86fa30e59bd9aa9?s=128&d=identicon&r=PG","display_name":"tholy","link":"https://stackoverflow.com/users/1939814/tholy"},"is_accepted":false,"score":0,"last_activity_date":1605449594,"creation_date":1605449594,"answer_id":64845402,"question_id":64835503,"content_license":"CC BY-SA 4.0","body":"<p>If you're writing your code in a file tracked by Revise, then deleting the method in the source will delete it in your running session. If I copy your two definitions to a file <code>/tmp/delmeth.jl</code>, then</p>\n<pre><code>julia&gt; using Revise\n\njulia&gt; Revise.includet(&quot;/tmp/delmeth.jl&quot;)\n\njulia&gt; foo(2)\n42\n\njulia&gt; foo(&quot;a&quot;)\n24\n</code></pre>\n<p>Now, in your editor, delete the method for <code>foo(::String)</code>, save the file, and in the same session do this:</p>\n<pre><code>julia&gt; foo(2)\n42\n\njulia&gt; foo(&quot;a&quot;)\nERROR: MethodError: no method matching foo(::String)\nClosest candidates are:\n  foo(::Integer) at /tmp/delmeth.jl:1\nStacktrace:\n [1] top-level scope\n   @ REPL[6]:1\n</code></pre>\n<p>If you're developing anything &quot;serious&quot; &amp; reusable, then you should generally create packages, in which case you don't need <code>includet</code> because Revise  automatically tracks packages that you've loaded with <code>using</code> or <code>import</code>. See the <a href=\"https://timholy.github.io/Revise.jl/stable/\" rel=\"nofollow noreferrer\">Revise docs</a> for further details.</p>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":false,"score":1,"last_activity_date":1605449376,"creation_date":1605449376,"answer_id":64845356,"question_id":64773600,"content_license":"CC BY-SA 4.0","body":"<p>See the PyPlot docs here: <a href=\"https://github.com/JuliaPy/PyPlot.jl\" rel=\"nofollow noreferrer\">https://github.com/JuliaPy/PyPlot.jl</a> for details on setting up interactive plots and such.</p>\n<p>This gist may also be of use to you: <a href=\"https://gist.github.com/gizmaa/7214002\" rel=\"nofollow noreferrer\">https://gist.github.com/gizmaa/7214002</a>. I would also suggest looking into <a href=\"http://makie.juliaplots.org/stable/\" rel=\"nofollow noreferrer\">Makie.jl</a> for more rich interactive plotting.</p>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":true,"score":1,"last_activity_date":1605448889,"creation_date":1605448889,"answer_id":64845264,"question_id":64785931,"content_license":"CC BY-SA 4.0","body":"<p>There is only one official Julia VS Code Extension at the moment which does support autocompletion: <a href=\"https://www.julia-vscode.org\" rel=\"nofollow noreferrer\">https://www.julia-vscode.org</a></p>\n<p>The different results you see is just a factor of what the various IDE's are searching for when they populate that autocomplete list.</p>\n<p><a href=\"https://i.stack.imgur.com/sfP5I.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/sfP5I.png\" alt=\"Image showing autocomplete in VS Code\" /></a></p>\n<p>Note that this is on the radar of the Julia VS Code team: <a href=\"https://github.com/julia-vscode/julia-vscode/issues/1199\" rel=\"nofollow noreferrer\">https://github.com/julia-vscode/julia-vscode/issues/1199</a></p>\n"},{"owner":{"reputation":2067,"user_id":7475838,"user_type":"registered","accept_rate":89,"profile_image":"https://www.gravatar.com/avatar/c1d7dfe36b15887b73dc5a577483d1d3?s=128&d=identicon&r=PG","display_name":"Rene","link":"https://stackoverflow.com/users/7475838/rene"},"is_accepted":true,"score":2,"last_activity_date":1605431107,"last_edit_date":1605431107,"creation_date":1605425748,"answer_id":64842141,"question_id":64841101,"content_license":"CC BY-SA 4.0","body":"<p>If I understand you correctly, you just want to use the greek symbol alpha <code>α</code>. For that you don't need the package <code>LaTeXString</code>. You can just type <code>\\alpha</code> and hit the <code>TAB</code> key. Then <code>\\alpha</code> should automagically change to <code>α</code>.</p>\n<p><code>LaTeXStrings</code> is used to type LaTeX equations in string literals, like in <code>L&quot;1 + \\alpha^2&quot;</code></p>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":false,"score":1,"last_activity_date":1605406539,"creation_date":1605406539,"answer_id":64840609,"question_id":64792254,"content_license":"CC BY-SA 4.0","body":"<p>In general, when I get behavior like this, the first step is always to restart my IDE, quit Julia, and re-try. Just tested this and it works for me, can you perhaps open an issue here: <a href=\"https://github.com/timholy/Revise.jl\" rel=\"nofollow noreferrer\">https://github.com/timholy/Revise.jl</a> if this is still an issue or provide steps to reproduce.</p>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":false,"score":0,"last_activity_date":1605406392,"creation_date":1605406392,"answer_id":64840599,"question_id":64794457,"content_license":"CC BY-SA 4.0","body":"<p>Please see the CUDAnative docs here: <a href=\"https://juliagpu.gitlab.io/CUDA.jl/installation/conditional/\" rel=\"nofollow noreferrer\">https://juliagpu.gitlab.io/CUDA.jl/installation/conditional/</a> for details on this issue and troubleshooting steps: <a href=\"https://juliagpu.gitlab.io/CUDA.jl/installation/troubleshooting/\" rel=\"nofollow noreferrer\">https://juliagpu.gitlab.io/CUDA.jl/installation/troubleshooting/</a>.</p>\n<p>If you continue to have this issue, please open an issue for the package on GitHub.</p>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":true,"score":0,"last_activity_date":1605405964,"creation_date":1605405964,"answer_id":64840560,"question_id":64806733,"content_license":"CC BY-SA 4.0","body":"<p>To reiterate what Matt and Bogumil said, Julia does not support recycling, it's a bug: <a href=\"https://github.com/JuliaLang/julia/issues/38019\" rel=\"nofollow noreferrer\">https://github.com/JuliaLang/julia/issues/38019</a></p>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":false,"score":2,"last_activity_date":1605405813,"creation_date":1605405813,"answer_id":64840545,"question_id":64835852,"content_license":"CC BY-SA 4.0","body":"<p>These are indeed some of the more tricky situations to resolve so please bear with me as we work through this.</p>\n<ol>\n<li>I would first suggest that you switch over from Pluto to the Julia Repl (the command-line version of Julia) as it makes running the Pkg command much easier. You can run by typing <code>julia</code> in the terminal or by opening the julia &quot;desktop app&quot; downloaded from <a href=\"https://julialang.org\" rel=\"nofollow noreferrer\">https://julialang.org</a>.</li>\n<li>If you are not familiar with the basics of the package manager, it's worth a quick read to check out: <a href=\"https://julialang.github.io/Pkg.jl/v1/getting-started/\" rel=\"nofollow noreferrer\">https://julialang.github.io/Pkg.jl/v1/getting-started/</a></li>\n<li>Assuming you are now in the Julia Repl, my general work flow for these issues is to remove everything it warns me about. The core problem here is that one of your existing packages is saying it needs a specific version of Distributions.jl but it's not able to add it. So, the first step would be to enter the pkg manager by doing <code>]</code> and type <code>rm Distributions</code>.</li>\n<li>Then, while still in the pkg mode, do <code>resolve</code> and <code>add Distributions</code>.</li>\n</ol>\n<p>Let me know if you still run into the issue after that (please edit your original question with the updated info).</p>\n"},{"owner":{"reputation":4744,"user_id":7619808,"user_type":"registered","profile_image":"https://i.stack.imgur.com/gHvtS.png?s=128&g=1","display_name":"logankilpatrick","link":"https://stackoverflow.com/users/7619808/logankilpatrick"},"is_accepted":false,"score":1,"last_activity_date":1605405595,"creation_date":1605405595,"answer_id":64840533,"question_id":64822972,"content_license":"CC BY-SA 4.0","body":"<p>You should open an issue on the Gzip GitHub repo and ask this first part of your question there (I am not a Gzip expert unfortunately).</p>\n<p>On the second point, I suggest looking here: <a href=\"https://github.com/JuliaIO/FileIO.jl/blob/master/README.md\" rel=\"nofollow noreferrer\">https://github.com/JuliaIO/FileIO.jl/blob/master/README.md</a> for lots of examples of FileIO loops which seems exactly what you need to replicate that Python loop. For the second part of this question, you best bet for that function is to try and hunt down the definition on GitHub or in the docs somewhere.</p>\n<p>For the 3rd questions, <code>coordinate_push.jl</code> does not need to be in the same folder as your &quot;main file&quot; (I am not sure what you mean by this so perhaps it would help to add context on the structure of your files). To import that file all you need to do is add <code>include(&quot;path/to/coordinate_push.jl&quot;)</code> at the top of the file you want to call/run the code from. It's worth noting that the path can either be the absolute path or the relative project path (in some cases).</p>\n"},{"owner":{"reputation":5456,"user_id":7210250,"user_type":"registered","accept_rate":50,"profile_image":"https://www.gravatar.com/avatar/f9e36056bc843650f91411fcb4d7bb58?s=128&d=identicon&r=PG&f=1","display_name":"Georgery","link":"https://stackoverflow.com/users/7210250/georgery"},"is_accepted":false,"score":6,"last_activity_date":1605367661,"creation_date":1605367661,"answer_id":64835504,"question_id":64835503,"content_license":"CC BY-SA 4.0","body":"<p>There is a type <code>Method</code>. Instances of that type refer to a specific method of a particular function.</p>\n<pre><code>particular_method = @which foo(2)\nfoo(a::Integer) in Main at /home/js/Documents/Julia/Matching/Query_Creation.jl:75\n\ntypeof(particular_method)\nMethod\n</code></pre>\n<p>And here's a way to delete the method using such an object:</p>\n<pre><code>Base.delete_method(particular_method)\n\nfoo(2)\nERROR: MethodError: no method matching foo(::Int64)\n</code></pre>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":true,"score":5,"last_activity_date":1605336936,"creation_date":1605336936,"answer_id":64831623,"question_id":64830895,"content_license":"CC BY-SA 4.0","body":"<p>Write:</p>\n<pre><code>@variable(mod, x, Bin)\n</code></pre>\n<p>You might also want to checkout the the <a href=\"https://jump.dev/JuMP.jl/stable/variables/#Binary-(ZeroOne)-constraints-1\" rel=\"noreferrer\">documentation</a> for more examples.</p>\n"},{"owner":{"reputation":368,"user_id":5602149,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/aa61c67a02a4288223ad4a1e789de947?s=128&d=identicon&r=PG","display_name":"Benoit Pasquier","link":"https://stackoverflow.com/users/5602149/benoit-pasquier"},"is_accepted":false,"score":6,"last_activity_date":1605320909,"creation_date":1605320909,"answer_id":64830362,"question_id":64828632,"content_license":"CC BY-SA 4.0","body":"<p>What about</p>\n<pre><code>vcat(transpose(x), transpose(y))\n</code></pre>\n<p>or</p>\n<pre><code>[transpose(x); transpose(y)]\n</code></pre>\n"},{"owner":{"reputation":13581,"user_id":9957710,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-xgjNutv-CqM/AAAAAAAAAAI/AAAAAAAABS8/EBDwfir_mYk/photo.jpg?sz=128","display_name":"Przemyslaw Szufel","link":"https://stackoverflow.com/users/9957710/przemyslaw-szufel"},"is_accepted":false,"score":7,"last_activity_date":1605312452,"creation_date":1605312452,"answer_id":64829606,"question_id":64828632,"content_license":"CC BY-SA 4.0","body":"<p>One more option - this one works both with numbers <em>and</em> other objects as <code>String</code>s:</p>\n<pre><code>julia&gt; rotl90([y x])\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n</code></pre>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":true,"score":9,"last_activity_date":1605310931,"last_edit_date":1605310931,"creation_date":1605307543,"answer_id":64829001,"question_id":64828632,"content_license":"CC BY-SA 4.0","body":"<p>Note that in <code>vcat(x', y')</code> the operation <code>x'</code> is adjoint so it should not be used if you are working with complex numbers or vector elements that do not have adjoint defined (e.g. strings). Therefore then <code>permutedims</code> should be used but it will be slower as it allocates. A third way to do it is (admittedly it is more cumbersome to type):</p>\n<pre><code>julia&gt; [reshape(x, 1, :); reshape(y, 1, :)]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n</code></pre>\n<p>It is non allocating like <code>[x'; y']</code> but does not do a recursive adjoint.</p>\n<p>EDIT:</p>\n<p>Note for Cameron:</p>\n<pre><code>julia&gt; x = repeat(string.('a':'z'), 10^6);\n\njulia&gt; @btime $x';\n  1.199 ns (0 allocations: 0 bytes)\n\njulia&gt; @btime reshape($x, 1, :);\n  36.455 ns (2 allocations: 96 bytes)\n</code></pre>\n<p>so <code>reshape</code> allocates but only minimally (it needs to create an array object, while <code>x'</code> creates an immutable struct which does not require allocation).</p>\n<p>Also I think it was a design decision to allocate. As for <code>isbitsunion</code> types actually <code>reshape</code> returns a struct so it does not allocate (similarly like for ranges):</p>\n<pre><code>julia&gt; @btime reshape($x, 1, :)\n  12.211 ns (0 allocations: 0 bytes)\n1×2 reshape(::Array{Union{Missing, Int64},1}, 1, 2) with eltype Union{Missing, Int64}:\n 1  missing\n</code></pre>\n"},{"owner":{"reputation":606,"user_id":4174466,"user_type":"registered","profile_image":"https://graph.facebook.com/1094010147/picture?type=large","display_name":"Scott Staniewicz","link":"https://stackoverflow.com/users/4174466/scott-staniewicz"},"is_accepted":false,"score":7,"last_activity_date":1605305530,"creation_date":1605305530,"answer_id":64828688,"question_id":64828632,"content_license":"CC BY-SA 4.0","body":"<p>Two ways I know of:</p>\n<pre><code>julia&gt; x = [1,2];\njulia&gt; y = [3,4];\njulia&gt; vcat(x', y')\n2×2 Array{Int64,2}:\n 1  2\n 3  4\njulia&gt; permutedims(hcat(x, y))\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n</code></pre>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":true,"score":2,"last_activity_date":1605293174,"last_edit_date":1605293174,"creation_date":1605284017,"answer_id":64824280,"question_id":64823551,"content_license":"CC BY-SA 4.0","body":"<p>Here are two ways to do it:</p>\n<pre><code>julia&gt; df = DataFrame(a=[1, missing, 3], b=[4, 5, missing])\n3×2 DataFrame\n│ Row │ a       │ b       │\n│     │ Int64?  │ Int64?  │\n├─────┼─────────┼─────────┤\n│ 1   │ 1       │ 4       │\n│ 2   │ missing │ 5       │\n│ 3   │ 3       │ missing │\n\njulia&gt; df[.!completecases(df), :] # this will be faster\n2×2 DataFrame\n│ Row │ a       │ b       │\n│     │ Int64?  │ Int64?  │\n├─────┼─────────┼─────────┤\n│ 1   │ missing │ 5       │\n│ 2   │ 3       │ missing │\n\njulia&gt; @view df[.!completecases(df), :]\n2×2 SubDataFrame\n│ Row │ a       │ b       │\n│     │ Int64?  │ Int64?  │\n├─────┼─────────┼─────────┤\n│ 1   │ missing │ 5       │\n│ 2   │ 3       │ missing │\n\njulia&gt; filter(row -&gt; any(ismissing, row), df)\n2×2 DataFrame\n│ Row │ a       │ b       │\n│     │ Int64?  │ Int64?  │\n├─────┼─────────┼─────────┤\n│ 1   │ missing │ 5       │\n│ 2   │ 3       │ missing │\n\njulia&gt; filter(row -&gt; any(ismissing, row), df, view=true) # requires DataFrames.jl 0.22\n2×2 SubDataFrame\n Row │ a        b\n     │ Int64?   Int64?\n─────┼──────────────────\n   1 │ missing        5\n   2 │       3  missing\n</code></pre>\n"},{"owner":{"reputation":4338,"user_id":4092216,"user_type":"registered","profile_image":"https://i.stack.imgur.com/nnp7O.jpg?s=128&g=1","display_name":"Cameron Bieganek","link":"https://stackoverflow.com/users/4092216/cameron-bieganek"},"is_accepted":false,"score":2,"last_activity_date":1605282492,"creation_date":1605282492,"answer_id":64823858,"question_id":64823505,"content_license":"CC BY-SA 4.0","body":"<p>Yes, it is possible. Any top-level variable in a module or package can be imported.</p>\n<pre><code>julia&gt; module A\n           x = 1\n           \n           macro foo(x)\n               x\n           end\n       end\nMain.A\n\njulia&gt; using .A: x, @foo\n\njulia&gt; x\n1\n\njulia&gt; @foo 2 + 2\n4\n</code></pre>\n<p>However, note that <code>using</code> and <code>import</code> statements still load the entire package. The part that you have control over is which names get added to your namespace.</p>\n"},{"owner":{"reputation":1935,"user_id":10447964,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-6f9lbppkbtM/AAAAAAAAAAI/AAAAAAAAACA/aCEFKA97ExU/photo.jpg?sz=128","display_name":"Kristoffer Carlsson","link":"https://stackoverflow.com/users/10447964/kristoffer-carlsson"},"is_accepted":true,"score":5,"last_activity_date":1605270858,"creation_date":1605270858,"answer_id":64820980,"question_id":64820651,"content_license":"CC BY-SA 4.0","body":"<p>You are defining functions on arrays instead of scalars and also restrict the input types too much. Also, for scalar functions you should use <code>ForwardDiff.derivative</code>. Try something like:</p>\n<pre><code>using Plots\nusing ForwardDiff\n\nmy_func(x::Real) =  1f0 / (1f0 + exp(3f0 * x))\nmy_func_derivative(x::Real) = ForwardDiff.derivative(my_func, x)\n\nplot(my_func, xlimits = (0, 10))\nplot!(my_func_derivative)\n</code></pre>\n<p>giving:</p>\n<p><a href=\"https://i.stack.imgur.com/FP87E.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/FP87E.png\" alt=\"enter image description here\" /></a></p>\n"},{"owner":{"reputation":13581,"user_id":9957710,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-xgjNutv-CqM/AAAAAAAAAAI/AAAAAAAABS8/EBDwfir_mYk/photo.jpg?sz=128","display_name":"Przemyslaw Szufel","link":"https://stackoverflow.com/users/9957710/przemyslaw-szufel"},"is_accepted":true,"score":4,"last_activity_date":1605208449,"last_edit_date":1605208449,"creation_date":1605207777,"answer_id":64810165,"question_id":64808351,"content_license":"CC BY-SA 4.0","body":"<p>I am strongly against reinventing the wheel and using custom-made parsers due to practivcal robustness of such solutions in production.</p>\n<p>If your file is in a single <code>String</code> use:</p>\n<pre><code>using DelimitedFiles\nreaddlm(IOBuffer(strs))\n</code></pre>\n<p>If your file as a <code>Vector</code> of <code>String</code>s use</p>\n<pre><code>cat(readdlm.(IOBuffer.(strsa))...,dims=1)\n</code></pre>\n<p>Finally, there is not conflict in using memory maps togehther with CSV:</p>\n<pre><code>using Mmap\n\ns = open(&quot;d.txt&quot;) # d.txt contains your lines\n                  # if you want to read &amp; wrtie use &quot;w+&quot; option\n \nm = Mmap.mmap(s, Vector{UInt8}) # memory mapping of your file\n\nreaddlm(IOBuffer(m))\n\n</code></pre>\n<p>At the same time you can always set the stream to the beginning and read the data regardless the memory map:</p>\n<pre><code>seek(s,0)\nreaddlm(s)\nseek(s,0) # reset the stream\n</code></pre>\n"},{"owner":{"reputation":4338,"user_id":4092216,"user_type":"registered","profile_image":"https://i.stack.imgur.com/nnp7O.jpg?s=128&g=1","display_name":"Cameron Bieganek","link":"https://stackoverflow.com/users/4092216/cameron-bieganek"},"is_accepted":false,"score":2,"last_activity_date":1605205433,"creation_date":1605205433,"answer_id":64809626,"question_id":64808351,"content_license":"CC BY-SA 4.0","body":"<pre><code>strs = [&quot;0.0000000E+00  0.0000000E+00  0.0000000E+00  1.3308000E+01&quot;,\n        &quot;0.0000000E+00  0.0000000E+00  1.9987500E-01  1.3308000E+01&quot;,\n        &quot;0.0000000E+00  0.0000000E+00  1.1998650E+00  1.3308000E+01&quot;]\n\nmapreduce(vcat, strs) do s\n    (parse.(Float64, split(s, &quot;  &quot;)))'\nend\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>3×4 Array{Float64,2}:\n 0.0  0.0  0.0       13.308\n 0.0  0.0  0.199875  13.308\n 0.0  0.0  1.19986   13.308\n</code></pre>\n"},{"owner":{"reputation":87,"user_id":13570848,"user_type":"registered","profile_image":"https://lh4.googleusercontent.com/-CgOIlS_UEkQ/AAAAAAAAAAI/AAAAAAAAAAA/AMZuuckzN4PXA5Ib4h3ate7dRWdmJVpNDw/photo.jpg?sz=128","display_name":"cardoza2","link":"https://stackoverflow.com/users/13570848/cardoza2"},"is_accepted":false,"score":1,"last_activity_date":1605202425,"creation_date":1605202425,"answer_id":64808883,"question_id":64808351,"content_license":"CC BY-SA 4.0","body":"<p>I made a work around. Not the most slick thing, but it works...</p>\n<pre><code>function rmspaces(line)\n    line = replace(line, &quot;\\t&quot; =&gt; &quot; &quot;)\n    # println(&quot;line: &quot;, line)\n    while occursin(&quot;  &quot;, line)\n        line = replace(line, &quot;  &quot;=&gt;&quot; &quot;)\n        # println(&quot;line: &quot;, line)\n    end\n\n    return line\nend\n\nfunction readmatrix(lines, numcolumns::Int64; type=Float64)\n    #Remove the spaces to one\n    for i=1:length(lines)\n        lines[i] = rmspaces(lines[i])\n    end\n\n    matrix = zeros(length(lines), numcolumns)\n\n    for i=1:length(lines)\n        idx = 1 # set the initial stop at the beginning\n        spot = 1\n        for j=1:length(lines[i])\n            if lines[i][j]==' ' &amp;&amp; j&gt;1 #Stops at spaces\n                number = parse(type,lines[i][idx:j]) #from the last stop to this one\n                idx = j #Set this stop in memory\n                matrix[i,spot] = number\n                spot += 1\n            end\n        end\n        if spot&lt;numcolumns+1 #If there isn't a space after the last number,\n            #we need to attach the last number in every row. If the last number\n            #was appended, then the spot will be increased to be more than the number\n            #of columns.\n            number = parse(type, lines[i][idx:end])\n            matrix[i,spot] = number\n        end\n    end\n    return matrix\nend\n</code></pre>\n"},{"owner":{"reputation":13581,"user_id":9957710,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-xgjNutv-CqM/AAAAAAAAAAI/AAAAAAAABS8/EBDwfir_mYk/photo.jpg?sz=128","display_name":"Przemyslaw Szufel","link":"https://stackoverflow.com/users/9957710/przemyslaw-szufel"},"is_accepted":true,"score":3,"last_activity_date":1605181495,"last_edit_date":1605181495,"creation_date":1605180141,"answer_id":64802966,"question_id":64802561,"content_license":"CC BY-SA 4.0","body":"<p>SharedArrays works only within a single cluster node.\nIn other words this is used to share RAM memory between processes running on the same server.\nWhen you add another server obviously you will not see that memory.</p>\n<p>What you should do is to use <code>DistributedArrays.jl</code> instead:</p>\n<pre><code>using Distributed, DistributedArrays\naddprocs(2)\n@everywhere using DistributedArrays\na=dzeros((3,4),workers())\n@sync @distributed for i = 1:nworkers()\n    a_part = localpart(a) \n    vec(a_part) .= (1:length(a_part)) .+ 1000*myid()\nend\n</code></pre>\n<p>And let us now see <code>a</code>:</p>\n<pre><code>julia&gt; a\n3×4 DArray{Float64,2,Array{Float64,2}}:\n 2001.0  2004.0  3001.0  3004.0\n 2002.0  2005.0  3002.0  3005.0\n 2003.0  2006.0  3003.0  3006.0\n</code></pre>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":true,"score":2,"last_activity_date":1605177585,"creation_date":1605177585,"answer_id":64802331,"question_id":64801924,"content_license":"CC BY-SA 4.0","body":"<p>I am not sure if it is best, but a natural approach is to use anonymous functions here like this:</p>\n<pre><code>let\n    f(x) = x^2\n    g = x -&gt; x\n    for i=1:2\n        l = g\n        g = x -&gt; l(x) + f(l(x))\n        println(g(1))\n    end\nend\n</code></pre>\n<p>or like this</p>\n<pre><code>f(x) = x^2\ng = x -&gt; x\nfor i=1:4\n    l = g\n    global g = x -&gt; l(x) + f(l(x))\n    println(g(1))\nend\n</code></pre>\n<p>(I prefer the former option using <code>let</code> as it avoids using global variables)</p>\n<p>The issue is that <code>l</code> is a loop local variable that gets a fresh binding at each iteration, while <code>g</code> is external to the loop.</p>\n<p>You might also check out <a href=\"https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Let-Blocks\" rel=\"nofollow noreferrer\">this section</a> of the Julia manual.</p>\n"},{"owner":{"reputation":493,"user_id":13591160,"user_type":"registered","profile_image":"https://lh6.googleusercontent.com/-gXrgnmUK7Sg/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rfsMAFVGT8ih3UFFA8KqqALLKEGwA/photo.jpg?sz=128","display_name":"Oscar Dowson","link":"https://stackoverflow.com/users/13591160/oscar-dowson"},"is_accepted":true,"score":1,"last_activity_date":1605164908,"creation_date":1605164908,"answer_id":64799382,"question_id":64796932,"content_license":"CC BY-SA 4.0","body":"<p>This is a little advanced, and some of the plumbing is missing (you have to use <code>direct_model</code> at present), but you can go:</p>\n<pre><code>using JuMP, Gurobi\nmodel = direct_model(Gurobi.Optimizer())\n@variable(model, x &gt;= 0)\n@constraint(model, c1,     x &lt;= -1)\n@constraint(model, c2, 2 * x &lt;=  1)\noptimize!(model)\n@assert termination_status(model) == MOI.INFEASIBLE\ncompute_conflict!(model)\n\njulia&gt; MOI.get(model, MOI.ConstraintConflictStatus(), LowerBoundRef(x))\nIN_CONFLICT::ConflictParticipationStatusCode = 1\n\njulia&gt; MOI.get(model, MOI.ConstraintConflictStatus(), c1)\nIN_CONFLICT::ConflictParticipationStatusCode = 1\n\njulia&gt; MOI.get(model, MOI.ConstraintConflictStatus(), c2)\nNOT_IN_CONFLICT::ConflictParticipationStatusCode = 0\n</code></pre>\n"},{"owner":{"reputation":13581,"user_id":9957710,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-xgjNutv-CqM/AAAAAAAAAAI/AAAAAAAABS8/EBDwfir_mYk/photo.jpg?sz=128","display_name":"Przemyslaw Szufel","link":"https://stackoverflow.com/users/9957710/przemyslaw-szufel"},"is_accepted":true,"score":4,"last_activity_date":1605145346,"creation_date":1605145346,"answer_id":64796716,"question_id":64795628,"content_license":"CC BY-SA 4.0","body":"<p>Perhaps there is a better solution but this would work:</p>\n<pre><code>using CategoricalArrays, Statistics\n\nnbins = 5\nbreaks = Statistics.quantile(train, (1:nbins-1)/nbins)\n\ncat_train = cut(train, breaks;extend=true,labels=string.(&quot;BIN_&quot;,1:5))\n\ncat_test =  cut(test, breaks;extend=true,labels=string.(&quot;BIN_&quot;,1:5))\n</code></pre>\n"},{"owner":{"reputation":15159,"user_id":1346276,"user_type":"registered","accept_rate":70,"profile_image":"https://i.stack.imgur.com/Tu8Re.jpg?s=128&g=1","display_name":"phipsgabler","link":"https://stackoverflow.com/users/1346276/phipsgabler"},"is_accepted":false,"score":4,"last_activity_date":1605431806,"last_edit_date":1605431806,"creation_date":1605122246,"answer_id":64792790,"question_id":64785326,"content_license":"CC BY-SA 4.0","body":"<p>This is more of a comment, but I can't hesitate posting it.  This question apprars so often.  I'll tell you why that phenomenon must arise.</p>\n<p>A <code>Bag{Apple}</code> is a <code>Bag{Fruit}</code>, right? Because, when I have a <code>JuicePress{Fruit}</code>, I can give it a <code>Bag{Apple}</code> to make some juice, because <code>Apple</code>s are <code>Fruit</code>s.</p>\n<p>But now we run into a problem: my fruit juice factory, in which I process different fruits, has a failure.  I order a new <code>JuicePress{Fruit}</code>.  Now, I unfortunately get delivered a replacement <code>JuicePress{Lemon}</code> -- but <code>Lemon</code>s are <code>Fruit</code>s, so surely a <code>JuicePress{Lemon}</code> is a <code>JuicePress{Fruit}</code>, right?</p>\n<p>However, the next day, I feed apples to the new press, and the machine explodes.  I hope you see why: <code>JuicePress{Lemon}</code> is <strong>not</strong> a <code>JuicePress{Fruit}</code>.  On the contrary: a <code>JuicePress{Fruit}</code> is a <code>JuicePress{Lemon}</code> -- I can press lemons with a fruit-agnostic press!  They could have sent me a <code>JuicePress{Plant}</code>, though, since <code>Fruit</code>s are <code>Plant</code>s.</p>\n<p>Now we can get more abstract.  The real reason is: function input arguments are <em>contravariant</em>, while function output arguments are <em>covariant</em> (in an idealized setting)<sup>2</sup>.  That is, when we have</p>\n<pre><code>f : A -&gt; B\n</code></pre>\n<p>then I can pass in <em>supertypes of <code>A</code></em>, and end up with <em>subtypes of <code>B</code></em>.  Hence, when we fix the first argument, the induced function</p>\n<pre><code>(Tree -&gt; Apple) &lt;: (Tree -&gt; Fruit)\n</code></pre>\n<p>whenever <code>Apple &lt;: Fruit</code> -- this is the covariant case, it preserves the direction of <code>&lt;:</code>.  But when we fix the second one,</p>\n<pre><code>(Fruit -&gt; Juice) &lt;: (Apple -&gt; Juice)\n</code></pre>\n<p>whenever <code>Fruit &gt;: Apple</code> -- this <em>inverts</em> the diretion of <code>&lt;:</code>, and therefore is called <em><strong>contra</strong>variant</em>.</p>\n<p>This carries over to other parametric data types, since there, too, you usually have &quot;output-like&quot; parameters (as in the <code>Bag</code>), and &quot;input-like&quot; parameters (as with the <code>JuicePress</code>).  There can also be parameters that behave like neither (e.g., when they occur in both fashions) -- these are then called <strong>invariant</strong>.</p>\n<p>There are now two ways in which languages with parametric types solve this problem.  The, in my opinion, more elegant one is to mark every parameter: no annotation means invariant, <code>+</code> means covariant, <code>-</code> means contravariant (this has technical reasons -- those parameters are said to occur in &quot;positive&quot; and &quot;negative position&quot;).  So we had the <code>Bag[+T &lt;: Fruit]</code>, or the <code>JuicePress[-T &lt;: Fruit]</code> (should be Scala syntax, but I haven't tried it).  This makes subtyping more complicated, though.</p>\n<p>The other route to go is what Julia does (and, BTW, Java): all types are invariant<sup>1</sup>, but you can specify upper and lower unions at the call site.  So you have to say</p>\n<pre><code>makejuice(::JoicePress{&gt;:T}, ::Bag{&lt;:T}) where {T}\n</code></pre>\n<p>And that's how we arrive at the other answers.</p>\n<hr />\n<p><sup>1</sup><em>Except for tuples, but that's weird.</em></p>\n<p><sup>2</sup><em>This terminology comes from <a href=\"https://en.wikipedia.org/wiki/Functor#Covariance_and_contravariance\" rel=\"nofollow noreferrer\">category theory</a>. The <code>Hom</code>-functor is contravariant in the first, and covariant in the second argument.  There's an intuitive realization of subtyping through the &quot;forgetful&quot; functor from the category <code>Typ</code> to the poset of <code>Typ</code>es under the <code>&lt;:</code> relation.  And the CT terminology in turn comes from <a href=\"https://en.wikipedia.org/wiki/Covariance_and_contravariance_of_vectors\" rel=\"nofollow noreferrer\">tensors</a>.</em></p>\n"},{"owner":{"reputation":2067,"user_id":7475838,"user_type":"registered","accept_rate":89,"profile_image":"https://www.gravatar.com/avatar/c1d7dfe36b15887b73dc5a577483d1d3?s=128&d=identicon&r=PG","display_name":"Rene","link":"https://stackoverflow.com/users/7475838/rene"},"is_accepted":false,"score":2,"last_activity_date":1605121510,"creation_date":1605121510,"answer_id":64792624,"question_id":64791134,"content_license":"CC BY-SA 4.0","body":"<p>Seems to work with the <code>gr()</code> backend, so I expect LaTeXString is not supported by the <code>plotlyjs()</code> backend.</p>\n<p><a href=\"https://i.stack.imgur.com/avrTa.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/avrTa.png\" alt=\"enter image description here\" /></a></p>\n"},{"owner":{"reputation":13581,"user_id":9957710,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-xgjNutv-CqM/AAAAAAAAAAI/AAAAAAAABS8/EBDwfir_mYk/photo.jpg?sz=128","display_name":"Przemyslaw Szufel","link":"https://stackoverflow.com/users/9957710/przemyslaw-szufel"},"is_accepted":false,"score":4,"last_activity_date":1605109249,"creation_date":1605109249,"answer_id":64789518,"question_id":64785326,"content_license":"CC BY-SA 4.0","body":"<p>While the &quot;how it works&quot; discussion has been done in the another answer, the best way to implement your method is the following:</p>\n<pre><code>function bloch_vector_2d(a::AbstractArray{Complex{T}}) where T&lt;:Real\n    sum(a) + 5*one(T)  # returning something to see how this is working\nend\n</code></pre>\n<p>Now this will work like this:</p>\n<pre><code>julia&gt; bloch_vector_2d(ones(Complex{Float64},4,3))\n17.0 + 0.0im\n</code></pre>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":true,"score":6,"last_activity_date":1605096816,"creation_date":1605096816,"answer_id":64786235,"question_id":64785326,"content_license":"CC BY-SA 4.0","body":"<p>This issue is discussed in detail in the Julia Manual <a href=\"https://docs.julialang.org/en/v1/manual/types/#Parametric-Composite-Types\" rel=\"noreferrer\">here</a>.</p>\n<p>Quoting the relevant part of it:</p>\n<blockquote>\n<p>In other words, in the parlance of type theory, Julia's type parameters are invariant, rather than being covariant (or even contravariant). This is for practical reasons: while any instance of <code>Point{Float64}</code> may conceptually be like an instance of <code>Point{Real}</code> as well, the two types have different representations in memory:</p>\n<ul>\n<li>An instance of <code>Point{Float64}</code> can be represented compactly and efficiently as an immediate pair of 64-bit values;</li>\n<li>An instance of <code>Point{Real}</code> must be able to hold any pair of instances of <code>Real</code>. Since objects that are instances of Real can be of arbitrary size and structure, in practice an instance of <code>Point{Real}</code> must be represented as a pair of pointers to individually allocated Real objects.</li>\n</ul>\n</blockquote>\n<p>Now going back to your question how to write a method signature then you have:</p>\n<pre><code>julia&gt; Array{Complex{Float64},2} &lt;: Array{&lt;:Complex,2}\ntrue\n</code></pre>\n<p>Note the difference:</p>\n<ul>\n<li><code>Array{&lt;:Complex,2}</code> represents a union of all types that are 2D arrays whose eltype is a subtype of <code>Complex</code> (i.e. no array will have this exact type).</li>\n<li><code>Array{Complex,2}</code> is a type that an array can have and this type means that you can store <code>Complex</code> values in it that can have mixed parameter.</li>\n</ul>\n<p>Here is an example:</p>\n<pre><code>julia&gt; x = Complex[im 1im;\n                   1.0im Float16(1)im]\n2×2 Array{Complex,2}:\n   im         0+1im\n 0.0+1.0im  0.0+1.0im\n\njulia&gt; typeof.(x)\n2×2 Array{DataType,2}:\n Complex{Bool}     Complex{Int64}\n Complex{Float64}  Complex{Float16}\n</code></pre>\n<p>Also note that the notation <code>Array{&lt;:Complex,2}</code> is the same as writing <code>Array{T,2} where T&lt;:Complex</code> (or more compactly <code>Matrix{T} where T&lt;:Complex</code>).</p>\n"},{"owner":{"reputation":15159,"user_id":1346276,"user_type":"registered","accept_rate":70,"profile_image":"https://i.stack.imgur.com/Tu8Re.jpg?s=128&g=1","display_name":"phipsgabler","link":"https://stackoverflow.com/users/1346276/phipsgabler"},"is_accepted":false,"score":1,"last_activity_date":1605092627,"creation_date":1605092627,"answer_id":64785207,"question_id":64781305,"content_license":"CC BY-SA 4.0","body":"<p>I'd write Yegor's answer as</p>\n<pre><code>f_array = Function[identity]\nfor i in 2:3\n     push!(f_array, x -&gt; 3f_array[i-1](x))\nend\n</code></pre>\n<p>But more importantly, this is a well known pattern: iterated function application.  And it is already implemented, not in Base, but for example in <a href=\"https://juliacollections.github.io/IterTools.jl/stable/#IterTools.iterated\" rel=\"nofollow noreferrer\">IterTools.jl</a>, by which you should be able to write:</p>\n<pre><code>f_array(start, N) = collect(Iterators.take(iterated(x -&gt; 3x, start), N))\n</code></pre>\n<p>(I didn't test this, though.)</p>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":false,"score":4,"last_activity_date":1605106945,"last_edit_date":1605106945,"creation_date":1605091295,"answer_id":64784851,"question_id":64784139,"content_license":"CC BY-SA 4.0","body":"<p>As Peter O. commented it depends. But let me give you an example where batching is desired:</p>\n<pre><code>julia&gt; using Random, BenchmarkTools\n\njulia&gt; function f1()\n           x = Vector{Float64}(undef, 10^6)\n           y = zeros(10^6)\n           for i in 1:100\n               rand!(x)\n               y .+= x\n           end\n           return y\n       end\nf1 (generic function with 1 method)\n\njulia&gt; function f2()\n           y = zeros(10^6)\n           @inbounds for i in 1:100\n               @simd for j in 1:10^6\n                   y[j] += rand()\n               end\n           end\n           return y\n       end\nf2 (generic function with 1 method)\n\njulia&gt; function f3()\n           y = zeros(10^6)\n           @inbounds for i in 1:100\n               for j in 1:10^6\n                   y[j] += rand()\n               end\n           end\n           return y\n       end\nf3 (generic function with 1 method)\n\njulia&gt; function f4()\n           x = Vector{Float64}(undef, 10^6)\n           y = zeros(10^6)\n           @inbounds for i in 1:100\n               rand!(x)\n               @simd for j in 1:10^6\n                   y[j] += x[j]\n               end\n           end\n           return y\n       end\nf4 (generic function with 1 method)\n\njulia&gt; function f5()\n           x = Vector{Float64}(undef, 10^6)\n           y = zeros(10^6)\n           @inbounds for i in 1:100\n               rand!(x)\n               for j in 1:10^6\n                   y[j] += x[j]\n               end\n           end\n           return y\n       end\nf5 (generic function with 1 method)\n\njulia&gt; @btime f1();\n  171.816 ms (4 allocations: 15.26 MiB)\n\njulia&gt; @btime f2();\n  370.950 ms (2 allocations: 7.63 MiB)\n\njulia&gt; @btime f3();\n  412.871 ms (2 allocations: 7.63 MiB)\n\njulia&gt; @btime f4();\n  172.355 ms (4 allocations: 15.26 MiB)\n\njulia&gt; @btime f5();\n  174.676 ms (4 allocations: 15.26 MiB)\n</code></pre>\n<p>As you can see <code>f1</code> (and two variants using the loop <code>f4</code> and <code>f5</code>) are much faster than when not using the cache for storing generated random variables (<code>f2</code> and <code>f3</code> functions). I have shown both variants using and not using <code>@simd</code> for comparison.</p>\n<h3>EDIT</h3>\n<p>The comment by rafak is very good. Here are the benchmarks. As you can see there is still some difference, but much lower (as the most cost is generation of random numbers and not addition).</p>\n<pre><code>julia&gt; function g1(rnd)\n           x = Vector{Float64}(undef, 10^6)\n           y = zeros(10^6)\n           for i in 1:100\n               rand!(rnd, x)\n               y .+= x\n           end\n           return y\n       end\ng1 (generic function with 1 method)\n\njulia&gt; function g2(rnd)\n           y = zeros(10^6)\n           @inbounds for i in 1:100\n               @simd for j in 1:10^6\n                   y[j] += rand(rnd)\n               end\n           end\n           return y\n       end\ng2 (generic function with 1 method)\n\njulia&gt; function g3(rnd)\n           y = zeros(10^6)\n           @inbounds for i in 1:100\n               for j in 1:10^6\n                   y[j] += rand(rnd)\n               end\n           end\n           return y\n       end\ng3 (generic function with 1 method)\n\njulia&gt; using Random\n\njulia&gt; rnd = MersenneTwister();\n\njulia&gt; @btime g1($rnd);\n  168.874 ms (4 allocations: 15.26 MiB)\n\njulia&gt; @btime g2($rnd);\n  193.398 ms (2 allocations: 7.63 MiB)\n\njulia&gt; @btime g3($rnd);\n  192.320 ms (2 allocations: 7.63 MiB)\n</code></pre>\n"},{"owner":{"reputation":12185,"user_id":190791,"user_type":"registered","accept_rate":68,"profile_image":"https://www.gravatar.com/avatar/184e01dc2af2f6c6ec200b41af6892b9?s=128&d=identicon&r=PG&f=1","display_name":"Timoth&#233;e HENRY","link":"https://stackoverflow.com/users/190791/timoth%c3%a9e-henry"},"is_accepted":false,"score":1,"last_activity_date":1605078768,"creation_date":1605078768,"answer_id":64781994,"question_id":64781305,"content_license":"CC BY-SA 4.0","body":"<p>In the mean time, I also found a way using metaprogramming. I post this here as it could be useful for others:</p>\n<pre><code>f1(x) = x\n\nfor i in 2:N\n  prog = &quot;f$i(x) = 3 * f$(i-1)(x)&quot;\n  exp = Meta.parse(prog)\n  eval(exp)\nend\n\nf3(2)\n# 18\n</code></pre>\n"},{"owner":{"reputation":2555,"user_id":7313094,"user_type":"registered","profile_image":"https://i.stack.imgur.com/UyOau.jpg?s=128&g=1","display_name":"Yegor Androsov","link":"https://stackoverflow.com/users/7313094/yegor-androsov"},"is_accepted":true,"score":2,"last_activity_date":1605077875,"creation_date":1605077875,"answer_id":64781835,"question_id":64781305,"content_license":"CC BY-SA 4.0","body":"<p>When you use <code>fill</code> with <code>f</code> it sets expected type for the elements of <code>f_array</code> to <code>f</code>, in the code below I am switching to abstract type to make it possible to have any function in the array</p>\n<pre><code>  # create simple function just to initialize\n  f(x)=x\n  \n  # initialize array of functions\n  N = 3\n  f_array = Array{Function}(undef, N);\n  f_array[1] = f;\n\n  # now we update each function\n  for i in 2:N\n    f_array[i] = x -&gt; 3 * f_array[i-1](x)\n  end\n\n  print(f_array[3](2))\n</code></pre>\n<p>which produces a value of 18</p>\n"},{"owner":{"reputation":15375,"user_id":1225607,"user_type":"registered","accept_rate":80,"profile_image":"https://www.gravatar.com/avatar/d357831bc203a7218241ae77188009a5?s=128&d=identicon&r=PG","display_name":"Fran&#231;ois F&#233;votte","link":"https://stackoverflow.com/users/1225607/fran%c3%a7ois-f%c3%a9votte"},"is_accepted":false,"score":2,"last_activity_date":1605027348,"creation_date":1605027348,"answer_id":64773261,"question_id":64771989,"content_license":"CC BY-SA 4.0","body":"<p>In addition to other answers, here is another solution, more inline with what you were trying to do:</p>\n<pre class=\"lang-julia prettyprint-override\"><code>julia&gt; using Dates\njulia&gt; function countplayers()\n           println(&quot;$(now()) There are 42 players&quot;)\n       end\ncountplayers (generic function with 1 method)\n\n# Run `countplayers` every 3s, starting now (delay=0)\njulia&gt; t = Timer(_-&gt;countplayers(), 0, interval=3);\n2020-11-10T17:52:42.904 There are 42 players\n2020-11-10T17:52:45.896 There are 42 players\n2020-11-10T17:52:48.899 There are 42 players\n2020-11-10T17:52:51.902 There are 42 players\n2020-11-10T17:52:54.905 There are 42 players\n2020-11-10T17:52:57.908 There are 42 players\n2020-11-10T17:53:00.909 There are 42 players\n\n# When you want to stop the task\njulia&gt; close(t)\n</code></pre>\n"},{"owner":{"reputation":13581,"user_id":9957710,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-xgjNutv-CqM/AAAAAAAAAAI/AAAAAAAABS8/EBDwfir_mYk/photo.jpg?sz=128","display_name":"Przemyslaw Szufel","link":"https://stackoverflow.com/users/9957710/przemyslaw-szufel"},"is_accepted":false,"score":2,"last_activity_date":1605027242,"last_edit_date":1605027242,"creation_date":1605026912,"answer_id":64773131,"question_id":64771989,"content_license":"CC BY-SA 4.0","body":"<p>Extending on Stefan's suggestion how to start here is a full working and very useful code:</p>\n<pre><code>function dosomething(f, interval) \n    stopper = Ref(false)\n    task = @async while !stopper[]\n        f()\n        sleep(interval)\n    end\n    return task, stopper\nend\n</code></pre>\n<p>Now let us see this action:</p>\n<pre><code>julia&gt; task, stopper = dosomething(()-&gt;println(&quot;Hello World&quot;),10)\nHello World\n(Task (runnable) @0x000000001675c5d0, Base.RefValue{Bool}(false))\n\njulia&gt; Hello World\njulia&gt;\n\njulia&gt; stopper[]=true;  # I do not want my background process anymore running\n\n\njulia&gt; task    #after few seconds the status will be done\nTask (done) @0x000000001675c5d0\n</code></pre>\n<p>Finally, it also should be noted that in production systems usually the most robust approach is to use system tools such as <code>crontab</code> for controlling and managing such recurring events.</p>\n"},{"owner":{"reputation":26155,"user_id":659248,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/21aeae1f260365557523718bc19640f7?s=128&d=identicon&r=PG","display_name":"StefanKarpinski","link":"https://stackoverflow.com/users/659248/stefankarpinski"},"is_accepted":true,"score":1,"last_activity_date":1605101138,"last_edit_date":1605101138,"creation_date":1605024055,"answer_id":64772363,"question_id":64771989,"content_license":"CC BY-SA 4.0","body":"<p>The canonical way to do this is to start an async task and just run it in a loop and sleep in between:</p>\n<pre><code>@async while true\n    my_function()\n    sleep(15*60)\nend\n</code></pre>\n<p>Because this block is async, evaluating this will return immediately and the task will just run in the background until the program exits.</p>\n"},{"owner":{"reputation":620,"user_id":5363686,"user_type":"registered","profile_image":"https://i.stack.imgur.com/M2IHZ.png?s=128&g=1","display_name":"Serge de Gosson de Varennes","link":"https://stackoverflow.com/users/5363686/serge-de-gosson-de-varennes"},"is_accepted":false,"score":0,"last_activity_date":1605018003,"creation_date":1605018003,"answer_id":64770681,"question_id":64768728,"content_license":"CC BY-SA 4.0","body":"<p>You could try to follow this example which builds on what you've done:</p>\n<pre><code>using DifferentialEquations\nusing Plots\n\nfunction lorenz(du,u,p,t)\n du[1] = p[1]*(u[2]-u[1])\n du[2] = u[1]*(p[2]-u[3]) - u[2]\n du[3] = u[1]*u[2] - p[3]*u[3]\nend\n\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\np = (10.0,28.0,8/3)\nprob = ODEProblem(lorenz, u0, tspan,p)\nsol = solve(prob)\nxyzt = plot(sol, plotdensity=10000,lw=1.5)\nxy = plot(sol, plotdensity=10000, vars=(1,2))\nxz = plot(sol, plotdensity=10000, vars=(1,3))\nyz = plot(sol, plotdensity=10000, vars=(2,3))\nxyz = plot(sol, plotdensity=10000, vars=(1,2,3))\nplot(plot(xyzt,xyz),plot(xy, xz, yz, layout=(1,3),w=1), layout=(2,1))\n</code></pre>\n"},{"owner":{"reputation":734,"user_id":1494135,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/e463c630b761d6a6e3be272d558cce71?s=128&d=identicon&r=PG","display_name":"Andrej Oskin","link":"https://stackoverflow.com/users/1494135/andrej-oskin"},"is_accepted":true,"score":2,"last_activity_date":1605013095,"creation_date":1605013095,"answer_id":64769375,"question_id":64767091,"content_license":"CC BY-SA 4.0","body":"<p>There is no need to lock variables. When you are doing parallel calculations you can always think in the terms of Split-Combine strategy (sorry just invent this term in analogy with DataFrames calculation, you may also call it Map-Reduce approach). The idea is that you split calculations around different threads and do them independently and on the final stage you combine results together on a single thread. So your code can look like this (there can be syntax errors, since I can't run the code without <code>Particle</code> and other definitions, but I hope it is enough to give the idea)</p>\n<pre><code>function minby(itr; by=identity, init=nothing)\n     init = isnothing(init) ? pop!(itr) : init\n     mapreduce(x-&gt;(by(x)=&gt;x), (x,y)-&gt;(first(x)&gt;first(y)) ? y : x, itr; init=by(init)=&gt;init).second\nend\n\nfunction PSO(problem; max_iter=100,population=100,c1=1.4962,c2=1.4962,w=0.7298,wdamp=1.0)\n    dim = problem.dim\n    lb = problem.lb\n    ub = problem.ub\n    cost_func = problem.cost_func\n\n    gbest, particles = initialize_particles(problem, population)\n\n    # main loop\n    for iter in 1:max_iter\n        gbests = fill((gbest.cost, 0), Threads.nthreads())\n        @threads for i in 1:population\n            particles[i].velocity .= w .* particles[i].velocity .+\n                c1 .* rand(dim) .* (particles[i].best_position .- particles[i].position) .+\n                c2 .* rand(dim) .* (gbest.position .- particles[i].position)\n\n            particles[i].position .= particles[i].position .+ particles[i].velocity\n            particles[i].position .= max.(particles[i].position, lb)\n            particles[i].position .= min.(particles[i].position, ub)\n\n            particles[i].cost = cost_func(particles[i].position)\n\n            if particles[i].cost &lt; particles[i].best_cost\n                particles[i].best_position = copy(particles[i].position)\n                particles[i].best_cost = copy(particles[i].cost)\n        \n                if particles[i].best_cost &lt; gbests[Threads.threadid()][1]\n                    gbests[Threads.threadid()] = (particles[i].best_cost, i)\n                end\n            end\n        end\n        gbest1 = minby(gbests, by = x -&gt; x[1])\n        if gbest1[2] != 0\n            idx = gbest1[2]\n            gbest.position = copy(particles[idx].best_position)\n            gbest.cost = copy(particles[idx].best_cost)\n        end\n        w = w * wdamp\n        if iter % 50 == 1\n            println(&quot;Iteration &quot; * string(iter) * &quot;: Best Cost = &quot; * string(gbest.cost))\n            println(&quot;Best Position = &quot; * string(gbest.position))\n            println()\n        end\n    end\n    gbest, particles\nend\n</code></pre>\n<p>By the way, you may find that package <a href=\"https://github.com/mauro3/UnPack.jl\" rel=\"nofollow noreferrer\">UnPack.jl</a> is rather convinient. Instead of manual assignments, you can do just</p>\n<pre><code>using UnPack\nfunction PSO(problem; max_iter=100,population=100,c1=1.4962,c2=1.4962,w=0.7298,wdamp=1.0)\n    @unpack dim, lb, ub, cost_func = problem\n    ....\n\n</code></pre>\n"},{"owner":{"reputation":15375,"user_id":1225607,"user_type":"registered","accept_rate":80,"profile_image":"https://www.gravatar.com/avatar/d357831bc203a7218241ae77188009a5?s=128&d=identicon&r=PG","display_name":"Fran&#231;ois F&#233;votte","link":"https://stackoverflow.com/users/1225607/fran%c3%a7ois-f%c3%a9votte"},"is_accepted":true,"score":4,"last_activity_date":1605008217,"creation_date":1605008217,"answer_id":64768195,"question_id":64767942,"content_license":"CC BY-SA 4.0","body":"<p>There are a couple ways to customize the sorting order, using either the <code>lt</code> or <code>by</code> keyword arguments to <code>sort</code> (or <code>sort!</code>):</p>\n<ol>\n<li>using <code>lt</code>: you define a custom &quot;less-than&quot; operator for tuples. You encode in this comparison operator more or less the order as you'd express it in a plain way:</li>\n</ol>\n<pre><code>julia&gt; a=[(1.0,2),(3.0,1),(2.0,3),(2.0,2)];\n\njulia&gt; mylt((x1,y1), (x2,y2)) = x1&gt;x2 || (x1==x2 &amp;&amp; y1&lt;y2)\nmylt (generic function with 1 method)\n\njulia&gt; sort(a, lt=mylt)\n4-element Array{Tuple{Float64,Int64},1}:\n (3.0, 1)\n (2.0, 2)\n (2.0, 3)\n (1.0, 2)\n</code></pre>\n<p>2.using <code>by</code>: you define a transformation that is applied to each element in the array, and by which elements are sorted:</p>\n<pre><code>julia&gt; x_desc_then_y_asc((x,y)) = (-x, y)\nx_desc_then_y_asc (generic function with 1 method)\n\njulia&gt; sort(a, by=x_desc_then_y_asc)\n4-element Array{Tuple{Float64,Int64},1}:\n (3.0, 1)\n (2.0, 2)\n (2.0, 3)\n (1.0, 2)\n</code></pre>\n<p>The helper function in that variant is so short that I would make an anonymous function out of it:</p>\n<pre><code>julia&gt; sort(a, by=((x,y),)-&gt;(-x,y))\n4-element Array{Tuple{Float64,Int64},1}:\n (3.0, 1)\n (2.0, 2)\n (2.0, 3)\n (1.0, 2)\n</code></pre>\n<p>PS: note how &quot;tuple destructuring&quot; is used in all these examples in order to avoid indexing explicitly into tuples.</p>\n"},{"owner":{"reputation":368,"user_id":5602149,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/aa61c67a02a4288223ad4a1e789de947?s=128&d=identicon&r=PG","display_name":"Benoit Pasquier","link":"https://stackoverflow.com/users/5602149/benoit-pasquier"},"is_accepted":false,"score":3,"last_activity_date":1605008167,"creation_date":1605008167,"answer_id":64768182,"question_id":64767942,"content_license":"CC BY-SA 4.0","body":"<p>You can specify your own &quot;isless&quot; function for ordering, e.g.,:</p>\n<pre><code>julia&gt; myisless(x,y) = (x[1]&lt;y[1]) || (x[1]==y[1] &amp;&amp; x[2]&gt;y[2])\nmyisless (generic function with 1 method)\n\njulia&gt; a=[(1.0,2),(3.0,1),(2.0,3),(2.0,2)]\n4-element Array{Tuple{Float64,Int64},1}:\n (1.0, 2)\n (3.0, 1)\n (2.0, 3)\n (2.0, 2)\n\njulia&gt; sort!(a, lt=myisless, rev=true)\n4-element Array{Tuple{Float64,Int64},1}:\n (3.0, 1)\n (2.0, 2)\n (2.0, 3)\n (1.0, 2)\n</code></pre>\n<p>Or see Francois' answer which offers this and a smart alternative.</p>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":true,"score":4,"last_activity_date":1604961183,"last_edit_date":1604961183,"creation_date":1604960421,"answer_id":64760080,"question_id":64759616,"content_license":"CC BY-SA 4.0","body":"<p>The simplest way to do it is to use broadcasting:</p>\n<pre><code>julia&gt; df = DataFrame(2*rand(4,3), [:x1, :x2, :x3])\n4×3 DataFrame\n│ Row │ x1        │ x2       │ x3       │\n│     │ Float64   │ Float64  │ Float64  │\n├─────┼───────────┼──────────┼──────────┤\n│ 1   │ 0.945879  │ 1.59742  │ 0.882428 │\n│ 2   │ 0.0963367 │ 0.400404 │ 0.599865 │\n│ 3   │ 1.23356   │ 0.807691 │ 0.547917 │\n│ 4   │ 0.756098  │ 0.595673 │ 0.29678  │\n\njulia&gt; @. ifelse(df &gt; 1, df, 0.0)\n4×3 DataFrame\n│ Row │ x1      │ x2      │ x3      │\n│     │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┤\n│ 1   │ 0.0     │ 1.59742 │ 0.0     │\n│ 2   │ 0.0     │ 0.0     │ 0.0     │\n│ 3   │ 1.23356 │ 0.0     │ 0.0     │\n│ 4   │ 0.0     │ 0.0     │ 0.0     │\n</code></pre>\n<p>you can also <code>transform</code> for it if you prefer:</p>\n<pre><code>julia&gt; transform(df, names(df) .=&gt; ByRow(x -&gt; ifelse(x&gt;1, x, 0.0)) .=&gt; names(df))\n4×3 DataFrame\n│ Row │ x1      │ x2      │ x3      │\n│     │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┤\n│ 1   │ 0.0     │ 1.59742 │ 0.0     │\n│ 2   │ 0.0     │ 0.0     │ 0.0     │\n│ 3   │ 1.23356 │ 0.0     │ 0.0     │\n│ 4   │ 0.0     │ 0.0     │ 0.0     │\n</code></pre>\n<p>Also looking at the linked pandas solution DataFrames.jl seems faster in this case:</p>\n<pre><code>julia&gt; df = DataFrame(2*rand(2,3), [:x1, :x2, :x3])\n2×3 DataFrame\n Row │ x1       x2       x3       \n     │ Float64  Float64  Float64  \n─────┼────────────────────────────\n   1 │ 1.48781  1.20332  1.08071\n   2 │ 1.55462  1.66393  0.363993\n\njulia&gt; using BenchmarkTools\n\njulia&gt; @btime @. ifelse($df &gt; 1, $df, 0.0)\n  6.252 μs (58 allocations: 3.89 KiB)\n2×3 DataFrame\n Row │ x1       x2       x3      \n     │ Float64  Float64  Float64 \n─────┼───────────────────────────\n   1 │ 1.48781  1.20332  1.08071\n   2 │ 1.55462  1.66393  0.0\n</code></pre>\n<p>(in pandas for 2x3 data frame it was ranging from 163 µs to 2.26 ms)</p>\n"},{"owner":{"reputation":27258,"user_id":176071,"user_type":"registered","accept_rate":100,"profile_image":"https://www.gravatar.com/avatar/88b8fe9e9bc03bd33208830fa612dc50?s=128&d=identicon&r=PG","display_name":"Matt B.","link":"https://stackoverflow.com/users/176071/matt-b"},"is_accepted":false,"score":4,"last_activity_date":1604956104,"creation_date":1604956104,"answer_id":64759290,"question_id":64758052,"content_license":"CC BY-SA 4.0","body":"<p>So the answer here is... it's tricky.  And in fact, in general, this isn't possible <em>unless the macro itself supports it</em>.</p>\n<p>See, macros do their transformations at parse time — and often will exploit what you've <em>actually written</em> to mean something different and special.  For example, <code>@vlplot</code> will specially handle and support JSON-like <code>{}</code> syntaxes.  These aren't valid Julia code and can't be passed to a function you define (like <code>example</code>)!</p>\n<p>Now, it's tempting to see this and think, ok, let's make that outer <code>example</code> thing into a macro, too!  But it's not that easy.  I'm not sure it's possible to have a general answer that will always pass the arguments appropriately <em>and</em> get the hygiene correct.  I'm pretty sure you need to know something about how the macro you're calling handles its arguments.</p>\n"},{"owner":{"reputation":32854,"user_id":1269567,"user_type":"registered","profile_image":"https://i.stack.imgur.com/tLzFU.png?s=128&g=1","display_name":"Bogumił Kamiński","link":"https://stackoverflow.com/users/1269567/bogumi%c5%82-kami%c5%84ski"},"is_accepted":false,"score":3,"last_activity_date":1604962259,"last_edit_date":1604962259,"creation_date":1604951661,"answer_id":64758396,"question_id":64758052,"content_license":"CC BY-SA 4.0","body":"<p>you need to add <code>;</code> before <code>kwargs</code> to signal they are <code>kwargs</code> not positional arguments e.g.:</p>\n<pre><code>DoSomething(;spec=:EX, x=xcol, y=ycol, kwargs...)\n</code></pre>\n<p>(this is the answer for <code>DoSomething</code> being a function as this was the original formulation of the question)</p>\n"}],"has_more":false,"quota_max":300,"quota_remaining":285}